#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "QString"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_pushButton_clicked()
{
    //picture 角度+0.785398
    //picture0反转过后角度-0.785398

    ReadImage(&ho_Image, "C:/Users/sun/Desktop/clip.jpg");
    SetWindowAttr("background_color","black");
    OpenWindow(0,0,960,540,0,"","",&hv_WindowHandle);
    HDevWindowStack::Push(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
    /*   通过摄像头获得图片
    //Image Acquisition 01: Code generated by Image Acquisition 01
    OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "rgb", -1, "false",
      "default", "[0] C670i FHD Webcam", 0, -1, &hv_AcqHandle);
    GrabImage(&ho_Image, hv_AcqHandle);
    //Image Acquisition 01: Do something
    CloseFramegrabber(hv_AcqHandle);*/

}

void MainWindow::on_pushButton_2_clicked()
{
    //*找边缘
      EdgesSubPix(ho_Image, &ho_Edges, "canny", 2, 20, 40);
      //*填充
      GenRegionContourXld(ho_Edges, &ho_Region, "filled");
      //*all:所有圆*根据颜色特征找出圆       ******************** 50000可改使all成型
      SelectShape(ho_Region, &ho_all, "area", "and", 0, 100000);
      //根据颜色，找出内圆，并找到圆心
      SelectShape(ho_Region, &ho_inner, "area", "and", 4000, 40000);
      //*外接圆的位置以及半径
      SmallestCircle(ho_inner, &hv_InnerRow, &hv_InnerColumn, &hv_InnerRadius);
      //转换格式，变成Image
      RegionToBin(ho_all, &ho_AllBinImage, 255, 0, 960, 540);
      //用全局阈值分割图像。*图像分割
      Threshold(ho_AllBinImage, &ho_all, 255, 255);
      if (HDevWindowStack::IsOpen())
        ClearWindow(HDevWindowStack::GetActive());
      //把目标以外的内容删除
      //reduce_domain (Image, all, AllReduced)
      //select_shape (Region, part, 'area', 'and', 0, 32544)
      //region_to_bin (inner, innerBinImage, 255, 0, 960, 540)
      //减去两个图像->得到圆环ImageSub（一个同心圆）
      //sub_image (AllBinImage, innerBinImage, ImageSub, 1, 128)

      //threshold (ImageSub, Regions, 255, 255)
      //得到大圆的半径
      SmallestCircle(ho_all, &hv_Row, &hv_Column, &hv_Radius);
      //圆心Row ，Column，ROI_0代表最小外接圆Region
      GenCircle(&ho_ROI_0, hv_Row, hv_Column, hv_Radius);
      //Image代表带缺口的目标原图，ROI_0代表最小外接圆
      //reduce_domain (Image, ROI_0, ImageReduced)
      //也许不太有意义
      RegionToBin(ho_ROI_0, &ho_BinImage, 255, 0, 960, 540);
      //ImageSub1代表缺口和干扰
      SubImage(ho_BinImage, ho_AllBinImage, &ho_ImageSub1, 255, 128);
      //Image变区域
      Threshold(ho_ImageSub1, &ho_Regions1, 0, 0);
      //腐蚀算法，为了去除干扰，RegionErosion就是缺口      ***************** 可多腐蚀几次
      ErosionCircle(ho_Regions1, &ho_RegionErosion, 1.5);
      if (HDevWindowStack::IsOpen())
        ClearWindow(HDevWindowStack::GetActive());
      //显示当前图形窗口中的图像对象。
      if (HDevWindowStack::IsOpen())
        DispObj(ho_RegionErosion, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_inner, HDevWindowStack::GetActive());
      //最小的周围矩形与任何方向。
      SmallestRectangle2(ho_RegionErosion, &hv_Row1, &hv_Column1, &hv_Phi, &hv_Length1,
          &hv_Length2);
      //缺口中心Row1，Column1
      //integer centRow=(Row1+Row2)/2
      //integer centCol=(Column1+Column2)/2
      //Circle是新生成的包含待识别区域的region
      GenCircle(&ho_Circle, (hv_Row1+hv_InnerRow)/2, (hv_Column1+hv_InnerColumn)/2, hv_Radius-hv_InnerRadius);





      //960 540 是可以修改的
      RegionToBin(ho_Circle, &ho_BinImage1, 255, 0, 960, 540);
      //RegionDilation膨胀后的区域，作者希望能够让内圆边缘接近待识别区域！！！！！20的大小 目前决定了准确率
      DilationCircle(ho_inner, &ho_RegionDilation, 20);
      RegionToBin(ho_RegionDilation, &ho_BinImage2, 255, 0, 960, 540);
      //
      SubImage(ho_BinImage1, ho_BinImage2, &ho_ImageSub2, 1, 128);
      //Regions2为待识别区域
      Threshold(ho_ImageSub2, &ho_Regions2, 255, 255);
      //侵蚀   Regions2:相减后得到的左上角的月牙图形
      ErosionCircle(ho_Regions2, &ho_RegionErosion1, 2);
      //外接矩形
      SmallestRectangle2(ho_RegionErosion1, &hv_Row2, &hv_Column2, &hv_Phi1, &hv_Length11,
          &hv_Length21);





      //gen_rectangle2 (Rectangle, Row2, Column2, Phi1, Length11, Length21)
      //类似相减
      //reduce_domain (AllBinImage, Rectangle, ImageReduced1)
      //也许可以删除  **好像确实可以删除
      //threshold (ImageReduced1, Regions3, 100, 255)
      //dev_clear_window ()
      //region_to_bin (Regions3, BinImage3, 255, 0, 960, 540)
      //用待识别区域image减去 膨胀以后的内圆
      //sub_image (BinImage3, BinImage2, ImageSub3, 10, 100)
      //根据ImageSub3生成Regions4
      //threshold (ImageSub3, Regions4, 255, 255)
      //dev_clear_window ()
      //reduce_domain (Image, Regions4, ImageReduced2)
      //reduce_domain(Image, Image-Regions4, ImageReduced2)
      //threshold (ImageSub3, Region1, 0, 254)
      //dev_clear_window ()
      //what is it
      //reduce_domain (Image, Region1, ImageReduced3)





      //第12象限
      if (0 != (hv_Row>hv_Row1))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),-hv_Phi, "window", hv_Row2, hv_Column2,
              "black", HTuple(), HTuple());

      }
      else if (0 != (hv_Column>hv_Column1))
      {
        //第三象限
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),-(3.1415+hv_Phi), "window", hv_Row2,
              hv_Column2, "black", HTuple(), HTuple());

      }
      else
      {
        //第四象限
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),3.1415-hv_Phi, "window", hv_Row2, hv_Column2,
              "black", HTuple(), HTuple());
      }
      ui->label_2->setText(QString::number(-hv_Phi,'g',6));
}
